*** Begin Patch
*** Update File: backend/chatagent/app.py
@@
-@app.get("/", response_class=HTMLResponse)
-async def root():
-    from .web.templates.index import html as tmpl
-    return tmpl()
+@app.get("/", response_class=HTMLResponse)
+async def root():
+    # Return the compiled index HTML template
+    return load_index_html()
@@
-@app.get("/", response_class=HTMLResponse)
-async def ui():
-    return load_index_html()
+@app.get("/ui", response_class=HTMLResponse)
+async def ui():
+    # Legacy UI path for backward compatibility
+    return load_index_html()
@@
-@router.post("/projects/{pid}/chat")
-async def chat(pid: int, payload: dict):
-    text = payload.get("text","")
-    prov = GoogleProvider()
-    reply = await outer.handle_user_input(pid, text, prov)
-    return {"reply": reply}
+@router.post("/projects/{pid}/chat")
+async def chat(pid: int, payload: dict):
+    text = payload.get("text", "")
+    model = payload.get("model")
+    # Pass user-selected model to provider if provided
+    prov = GoogleProvider(model=model)
+    reply = await outer.handle_user_input(pid, text, prov)
+    return {"reply": reply}

*** End Patch

*** Begin Patch
*** Update File: backend/chatagent/agents/outer.py
@@ async def handle_user_input(project_id: int, user_text: str, provider) -> str:
-    # Very light stub that echoes a plan and enqueues a dummy task
-    with get_session() as s:
-        proj = s.get(Project, project_id)
-        add_message(s, project_id, "user", user_text)
-        # Summarize short context
-        summary = summarize_context(s, project_id)
-        system = SYSTEM_PROMPT + f"\n# Kontext:\n{summary}\n"
-        # For MVP: static reply and create a task
-        reply = "Rozumím. Vytváøím poèáteèní úkol: inicializace repozitáøe a README."
-        add_message(s, project_id, "outer", reply)
-        add_task(s, project_id, "Inicializace projektu", "queued", input="init repo + README")
-        s.commit()
-    return reply
+    # Record user message
+    with get_session() as s:
+        proj = s.get(Project, project_id)
+        add_message(s, project_id, "user", user_text)
+        # Special case: generate a Hello world program
+        if "hello world" in user_text.lower():
+            response_text = "Vytvoøím soubor hello.py s funkcí tisku 'Hello, world!' a spustím ho."
+            add_message(s, project_id, "outer", response_text)
+            # Schedule file creation and execution tasks
+            add_task(s, project_id, "Create hello.py", "queued", input='create_file hello.py print("Hello, world!")')
+            add_task(s, project_id, "Run hello.py", "queued", input='run python hello.py')
+            s.commit()
+            return response_text
+        # Otherwise, let the LLM generate a response using the provider
+        summary = summarize_context(s, project_id)
+        system = SYSTEM_PROMPT + f"\n# Kontext:\n{summary}\n"
+        messages = [{"role": "user", "content": user_text}]
+        try:
+            data = await provider.chat(messages=messages, tools=None, system=system)
+            # Attempt to extract a reply from the provider response
+            reply_text = None
+            if data:
+                cand = data.get("candidates") or data.get("choices")
+                if cand:
+                    first = cand[0]
+                    if isinstance(first, dict):
+                        reply_text = first.get("output", first.get("content"))
+                    elif isinstance(first, str):
+                        reply_text = first
+            if not reply_text:
+                reply_text = "Omlouvám se, ale nedokážu odpovìdìt."
+        except Exception as e:
+            reply_text = f"Chyba pøi volání modelu: {e}"
+        add_message(s, project_id, "outer", reply_text)
+        s.commit()
+        return reply_text

*** End Patch

*** Begin Patch
*** Update File: backend/chatagent/agents/inner.py
@@
-from ..tools import shell, git
-from .shared import add_message, set_task_status
+from ..tools import shell, git
+from .shared import add_message, set_task_status
+from sqlmodel import select
@@ async def worker_loop():
-        # Execute: init git, create README
-        readme = proj_dir / "README.md"
-        if not readme.exists():
-            readme.write_text(f"# {proj.title}\n\nInicializováno ChatAgent MVP.\n")
-        # git init & commit
-        async for out in git.git_init(str(proj_dir)):
-            add_message(get_session(), task.project_id, "inner", out)
-        async for out in git.git_commit_all(str(proj_dir), "chore: initial commit with README"):
-            add_message(get_session(), task.project_id, "inner", out)
-        with get_session() as s:
-            set_task_status(s, task.id, "done")
-            add_message(s, task.project_id, "inner", "Úkol hotov: inicializace provedena.")
+        instr = task.input.strip() if isinstance(task.input, str) else ""
+        message_done = ""
+        if instr.startswith("init"):
+            # Initialise git repository and README
+            readme = proj_dir / "README.md"
+            if not readme.exists():
+                readme.write_text(f"# {proj.title}\\n\\nInicializováno ChatAgent MVP.\\n")
+            async for out in git.git_init(str(proj_dir)):
+                add_message(get_session(), task.project_id, "inner", out)
+            async for out in git.git_commit_all(str(proj_dir), "chore: initial commit with README"):
+                add_message(get_session(), task.project_id, "inner", out)
+            message_done = "Úkol hotov: inicializace provedena."
+        elif instr.startswith("create_file"):
+            parts = instr.split(None, 2)
+            if len(parts) >= 3:
+                filename = parts[1]
+                content = parts[2]
+                file_path = proj_dir / filename
+                file_path.parent.mkdir(parents=True, exist_ok=True)
+                file_path.write_text(content)
+                # commit the new file
+                async for out in git.git_commit_all(str(proj_dir), f'chore: create {filename}'):
+                    add_message(get_session(), task.project_id, "inner", out)
+                message_done = f"Soubor {filename} vytvoøen."
+        elif instr.startswith("run"):
+            cmd = instr[len("run"):].strip()
+            output = ""
+            async for out in shell.run_shell(cmd, cwd=str(proj_dir)):
+                output += out
+                add_message(get_session(), task.project_id, "inner", out)
+            message_done = f"Spuštìní pøíkazu '{cmd}' dokonèeno."
+        # Mark task as done and record a completion message
+        with get_session() as s2:
+            set_task_status(s2, task.id, "done")
+            add_message(s2, task.project_id, "inner", message_done or "Úkol dokonèen.")

*** End Patch

*** Begin Patch
*** Update File: backend/chatagent/agents/shared.py
@@
 def summarize_context(s, project_id: int) -> str:
@@
     return f"Pamì:\\n{memtxt}\\n\\nPoslední zprávy:\\n{hist}"
+
+# Placeholder budget check used by the outer worker to ensure token and cost limits are respected.
+def budget_ok(s, project_id: int, tokens: int = 0, usd: float = 0.0) -> bool:
+    """
+    Returns True if the project budget has not been exceeded.
+    This MVP implementation always returns True.
+    """
+    return True

*** End Patch

*** Begin Patch
*** Update File: backend/chatagent/web/templates/index.html
@@
-    <textarea id="msg"></textarea>
+    <textarea id="msg"></textarea>
+    <label for="model">Model:</label>
+    <select id="model">
+      <option value="gemini-1.5-pro">gemini-1.5-pro</option>
+      <option value="gemini-1.5-flash">gemini-1.5-flash</option>
+    </select>
@@
 async function sendMsg(){
   if(!currentProjectId){ alert('Vyber projekt'); return; }
   const txt = document.getElementById('msg').value;
   document.getElementById('msg').value='';
-  const r = await fetch(`/api/projects/${currentProjectId}/chat`, {method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({text: txt})});
+  const model = document.getElementById('model').value;
+  const r = await fetch(`/api/projects/${currentProjectId}/chat`, {method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({text: txt, model})});
   const data = await r.json();
   document.getElementById('chat').innerText += "\\n" + data.reply;
 }

*** End Patch
